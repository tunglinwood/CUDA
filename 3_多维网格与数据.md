# 3_多维网格与数据

* [3.1 多维网格组织]()
* [3.2 线程与多维数据的映射]()
* [3.3 图像模糊：更复杂的内核]()
* [3.4 矩阵乘法]()
* [3.5 总结]()
* [练习]()

在第 2 章《异构数据并行计算》中，我们学习了如何编写一个简单的 CUDA C11 程序，该程序通过调用内核函数来操作一维数组的元素，从而启动一维线程网格。内核指定了网格中每个线程执行的语句。在本章中，我们将更一般地探讨线程的组织方式，并学习如何使用线程和块来处理多维数组。本章将通过多个示例进行讲解，包括将彩色图像转换为灰度图像、图像模糊处理和矩阵乘法。这些示例还旨在帮助读者理解数据并行性，然后我们将在接下来的章节中讨论 GPU 架构、内存组织和性能优化。

## 3.1 多维网格组织

在 CUDA 中，网格中的所有线程执行相同的内核函数，它们依靠坐标（即线程索引）来区分彼此，并确定处理数据的适当部分。正如我们在第 2 章《异构数据并行计算》中看到的，这些线程被组织成一个两级层次结构：一个网格由一个或多个块组成，每个块由一个或多个线程组成。块中的所有线程共享相同的块索引，可以通过 `blockIdx`（内置）变量访问。每个线程还有一个线程索引，可以通过 `threadIdx`（内置）变量访问。当线程执行内核函数时，`blockIdx` 和 `threadIdx` 变量的引用会返回线程的坐标。内核调用语句中的执行配置参数指定了网格的维度和每个块的维度。这些维度可以通过 `gridDim` 和 `blockDim`（内置）变量获取。

通常，网格是一个三维（3D）块数组，每个块是一个三维数组的线程。在调用内核时，程序需要指定网格和每个维度中块的大小。这些通过内核调用语句中的执行配置参数（在 <<<...>>> 中）进行指定。第一个执行配置参数指定网格的块维度。第二个参数指定每个块的线程维度。每个这样的参数都有 dim3 类型，它是一个包含三个元素 x、y 和 z 的整数向量类型。这三个元素指定了三个维度的大小。程序员可以通过将未使用维度的大小设置为 1 来使用少于三个维度。

例如，以下主机代码可以用来调用 `vecAddkernel()` 内核函数，并生成一个包含 32 个块的 1D 网格，每个块包含 128 个线程。网格中的线程总数为 128*32=4096：
```cuda
dim3 dimGrid(32, 1, 1);
dim3 dimBlock(128, 1, 1);
vecAddKernel<<<dimGrid,dimBlock>>>(...);
```
请注意，`dimBlock` 和 `dimGrid` 是由程序员定义的主机代码变量。这些变量可以具有任何合法的 C 变量名，只要它们的类型是 dim3。例如，以下语句实现了与上述语句相同的结果：
```cuda
dim3 dog(32, 1, 1);
dim3 cat(128, 1, 1);
vecAddKernel<<<dog, cat>>>(...);
```
网格和块的维度也可以从其他变量计算得出。例如，图 2.12 中的内核调用可以写成如下形式：
```cuda
dim3 dimGrid(ceil(n/256.0), 1, 1);
dim3 dimBlock(256, 1, 1);
vecAddKernel<<<dimGrid,dimBlock>>>(...);
```
这允许块的数量随着向量的大小变化，以便网格中有足够的线程来覆盖所有向量元素。在此示例中，程序员选择将块大小固定为 256。内核调用时变量 n 的值将决定网格的维度。如果 n 等于 1000，网格将由四个块组成。如果 n 等于 4000，网格将有 16 个块。在每种情况下，都有足够的线程来覆盖所有向量元素。一旦网格启动，网格和块的维度将在整个网格执行完成之前保持不变。

为了方便，CUDA 提供了一种特殊的快捷方式来调用具有一维（1D）网格和块的内核。无需使用 dim3 变量，可以使用算术表达式来指定 1D 网格和块的配置。在这种情况下，CUDA 编译器只需将算术表达式作为 x 维度，并假设 y 和 z 维度为 1。这为我们提供了图 2.12 中显示的内核调用语句：
```cuda
vecAddKernel<<<ceil(n/256.0), 256>>>(...);
```
熟悉 C++ 的读者会意识到，这种“简写”约定利用了 C++ 构造函数和默认参数的工作方式。dim3 构造函数的默认参数值为 1。当传递一个单一值时，该值将传递给构造函数的第一个参数，而第二和第三个参数将取默认值 1。结果是一个 1D 网格或块，其中 x 维度的大小是传递的值，而 y 和 z 维度的大小为 1。

在内核函数中，`gridDim` 和 `blockDim` 变量的 x 字段根据执行配置参数的值进行预初始化。例如，如果 n 等于 4000，则在 `vectAddkernel` 内核中对 `gridDim.x` 和 `blockDim.x` 的引用将分别得到 16 和 256。请注意，与主机代码中的 dim3 变量不同，这些变量在内核函数中是 CUDA C 规范的一部分，不能更改。即，`gridDim` 和 `blockDim` 是内核中的内置变量，始终反映网格和块的维度。

在 CUDA C 中，`gridDim.x` 的允许值范围是 1 到 2<sup>31</sup> - 1，`gridDim.y` 和 `gridDim.z` 的允许值范围是 1 到 2<sup>16</sup> - 1（65,535）。块中的所有线程共享相同的 `blockIdx.x`、`blockIdx.y` 和 `blockIdx.z` 值。在块之间，`blockIdx.x` 的值范围是 0 到 `gridDim.x-1`，`blockIdx.y` 的值范围是 0 到 `gridDim.y-1`，`blockIdx.z` 的值范围是 0 到 `gridDim.z-1`。

我们现在转向块的配置。每个块组织成一个 3D 线程数组。通过将 `blockDim.z` 设置为 1，可以创建二维（2D）块。通过将 `blockDim.y` 和 `blockDim.z` 都设置为 1，可以创建一维块，如 `vectorAddkernel` 示例中所示。正如我们之前提到的，网格中的所有块具有相同的维度和大小。块的每个维度中的线程数量由内核调用的第二个执行配置参数指定。在内核中，这个配置参数可以作为 `blockDim` 的 x、y 和 z 字段进行访问。

在当前的 CUDA 系统中，块的总大小限制为 1024 个线程。这些线程可以在三个维度中以任何方式分布，只要线程的总数不超过 1024。例如，`blockDim` 的值 (512, 1, 1)、(8, 16, 4) 和 (32, 16, 2) 都是允许的，但 (32, 32, 2) 不允许，因为线程的总数将超过 1024。

网格及其块不需要具有相同的维度。网格可以具有比块更高的维度，反之亦然。例如，图 3.1 显示了一个小型示例网格，`gridDim` 为 (2, 2, 1)，`blockDim` 为 (4, 2, 2)。这样的网格可以通过以下主机代码创建：
```cuda
dim3 dimGrid(2, 2, 1);
dim3 dimBlock(4, 2, 2);
vecAddKernel<<<dimGrid,dimBlock>>>(...);
```

> 图 3.1 CUDA 网格组织的多维示例

图 3.1 中的网格由四个块组成，组织成一个 2*2 的数组。每个块用 (`blockIdx.y`, `blockIdx.x`) 标记。例如，块 (1,0) 的 `blockIdx.y=1` 和 `blockIdx.x=0`。请注意，块和线程标签的排序方式是最高维度优先。这种标记方式的顺序与 C 语句中设置配置参数的顺序相反，

后者是最低维度优先。这种用于标记块的逆序在我们说明线程坐标映射到数据索引以访问多维数据时效果更好。

每个 `threadIdx` 也由三个字段组成：x 坐标 `threadId.x`、y 坐标 `threadIdx.y` 和 z 坐标 `threadIdx.z`。图 3.1 说明了块内线程的组织方式。在此示例中，每个块被组织成 43232 的线程数组。由于网格中的所有块具有相同的维度，我们仅展示其中一个。图 3.1 展开了块 (1,1) 以显示其 16 个线程。例如，线程 (1,0,2) 的 `threadIdx.z=1`、`threadIdx.y=0` 和 `threadIdx.x=2`。请注意，在此示例中，我们有 4 个块，每个块 16 个线程，总共有 64 个线程在网格中。我们使用这些小数字来保持插图的简单性。典型的 CUDA 网格包含成千上万甚至数百万个线程。
