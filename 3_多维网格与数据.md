# 3_多维网格与数据

* [3.1 多维网格组织]()
* [3.2 线程与多维数据的映射]()
* [3.3 图像模糊：更复杂的内核]()
* [3.4 矩阵乘法]()
* [3.5 总结]()
* [练习]()

在第 2 章《异构数据并行计算》中，我们学习了如何编写一个简单的 CUDA C11 程序，该程序通过调用内核函数来操作一维数组的元素，从而启动一维线程网格。内核指定了网格中每个线程执行的语句。在本章中，我们将更一般地探讨线程的组织方式，并学习如何使用线程和块来处理多维数组。本章将通过多个示例进行讲解，包括将彩色图像转换为灰度图像、图像模糊处理和矩阵乘法。这些示例还旨在帮助读者理解数据并行性，然后我们将在接下来的章节中讨论 GPU 架构、内存组织和性能优化。

## 3.1 多维网格组织

在 CUDA 中，网格中的所有线程执行相同的内核函数，它们依靠坐标（即线程索引）来区分彼此，并确定处理数据的适当部分。正如我们在第 2 章《异构数据并行计算》中看到的，这些线程被组织成一个两级层次结构：一个网格由一个或多个块组成，每个块由一个或多个线程组成。块中的所有线程共享相同的块索引，可以通过 `blockIdx`（内置）变量访问。每个线程还有一个线程索引，可以通过 `threadIdx`（内置）变量访问。当线程执行内核函数时，`blockIdx` 和 `threadIdx` 变量的引用会返回线程的坐标。内核调用语句中的执行配置参数指定了网格的维度和每个块的维度。这些维度可以通过 `gridDim` 和 `blockDim`（内置）变量获取。

通常，网格是一个三维（3D）块数组，每个块是一个三维数组的线程。在调用内核时，程序需要指定网格和每个维度中块的大小。这些通过内核调用语句中的执行配置参数（在 <<<...>>> 中）进行指定。第一个执行配置参数指定网格的块维度。第二个参数指定每个块的线程维度。每个这样的参数都有 dim3 类型，它是一个包含三个元素 x、y 和 z 的整数向量类型。这三个元素指定了三个维度的大小。程序员可以通过将未使用维度的大小设置为 1 来使用少于三个维度。

例如，以下主机代码可以用来调用 `vecAddkernel()` 内核函数，并生成一个包含 32 个块的 1D 网格，每个块包含 128 个线程。网格中的线程总数为 128*32=4096：
```cuda
dim3 dimGrid(32, 1, 1);
dim3 dimBlock(128, 1, 1);
vecAddKernel<<<dimGrid,dimBlock>>>(...);
```
请注意，`dimBlock` 和 `dimGrid` 是由程序员定义的主机代码变量。这些变量可以具有任何合法的 C 变量名，只要它们的类型是 dim3。例如，以下语句实现了与上述语句相同的结果：
```cuda
dim3 dog(32, 1, 1);
dim3 cat(128, 1, 1);
vecAddKernel<<<dog, cat>>>(...);
```
网格和块的维度也可以从其他变量计算得出。例如，图 2.12 中的内核调用可以写成如下形式：
```cuda
dim3 dimGrid(ceil(n/256.0), 1, 1);
dim3 dimBlock(256, 1, 1);
vecAddKernel<<<dimGrid,dimBlock>>>(...);
```
这允许块的数量随着向量的大小变化，以便网格中有足够的线程来覆盖所有向量元素。在此示例中，程序员选择将块大小固定为 256。内核调用时变量 n 的值将决定网格的维度。如果 n 等于 1000，网格将由四个块组成。如果 n 等于 4000，网格将有 16 个块。在每种情况下，都有足够的线程来覆盖所有向量元素。一旦网格启动，网格和块的维度将在整个网格执行完成之前保持不变。

为了方便，CUDA 提供了一种特殊的快捷方式来调用具有一维（1D）网格和块的内核。无需使用 dim3 变量，可以使用算术表达式来指定 1D 网格和块的配置。在这种情况下，CUDA 编译器只需将算术表达式作为 x 维度，并假设 y 和 z 维度为 1。这为我们提供了图 2.12 中显示的内核调用语句：
```cuda
vecAddKernel<<<ceil(n/256.0), 256>>>(...);
```
熟悉 C++ 的读者会意识到，这种“简写”约定利用了 C++ 构造函数和默认参数的工作方式。dim3 构造函数的默认参数值为 1。当传递一个单一值时，该值将传递给构造函数的第一个参数，而第二和第三个参数将取默认值 1。结果是一个 1D 网格或块，其中 x 维度的大小是传递的值，而 y 和 z 维度的大小为 1。

在内核函数中，`gridDim` 和 `blockDim` 变量的 x 字段根据执行配置参数的值进行预初始化。例如，如果 n 等于 4000，则在 `vectAddkernel` 内核中对 `gridDim.x` 和 `blockDim.x` 的引用将分别得到 16 和 256。请注意，与主机代码中的 dim3 变量不同，这些变量在内核函数中是 CUDA C 规范的一部分，不能更改。即，`gridDim` 和 `blockDim` 是内核中的内置变量，始终反映网格和块的维度。

在 CUDA C 中，`gridDim.x` 的允许值范围是 1 到 2<sup>31</sup> - 1，`gridDim.y` 和 `gridDim.z` 的允许值范围是 1 到 2<sup>16</sup> - 1（65,535）。块中的所有线程共享相同的 `blockIdx.x`、`blockIdx.y` 和 `blockIdx.z` 值。在块之间，`blockIdx.x` 的值范围是 0 到 `gridDim.x-1`，`blockIdx.y` 的值范围是 0 到 `gridDim.y-1`，`blockIdx.z` 的值范围是 0 到 `gridDim.z-1`。

我们现在转向块的配置。每个块组织成一个 3D 线程数组。通过将 `blockDim.z` 设置为 1，可以创建二维（2D）块。通过将 `blockDim.y` 和 `blockDim.z` 都设置为 1，可以创建一维块，如 `vectorAddkernel` 示例中所示。正如我们之前提到的，网格中的所有块具有相同的维度和大小。块的每个维度中的线程数量由内核调用的第二个执行配置参数指定。在内核中，这个配置参数可以作为 `blockDim` 的 x、y 和 z 字段进行访问。

在当前的 CUDA 系统中，块的总大小限制为 1024 个线程。这些线程可以在三个维度中以任何方式分布，只要线程的总数不超过 1024。例如，`blockDim` 的值 (512, 1, 1)、(8, 16, 4) 和 (32, 16, 2) 都是允许的，但 (32, 32, 2) 不允许，因为线程的总数将超过 1024。

网格及其块不需要具有相同的维度。网格可以具有比块更高的维度，反之亦然。例如，图 3.1 显示了一个小型示例网格，`gridDim` 为 (2, 2, 1)，`blockDim` 为 (4, 2, 2)。这样的网格可以通过以下主机代码创建：
```cuda
dim3 dimGrid(2, 2, 1);
dim3 dimBlock(4, 2, 2);
vecAddKernel<<<dimGrid,dimBlock>>>(...);
```

![image](https://github.com/user-attachments/assets/0f949238-6fc6-4da3-8e08-ed7d07d80b71)
> 图 3.1 CUDA 网格组织的多维示例

图 3.1 中的网格由四个块组成，组织成一个 2*2 的数组。每个块用 (`blockIdx.y`, `blockIdx.x`) 标记。例如，块 (1,0) 的 `blockIdx.y=1` 和 `blockIdx.x=0`。请注意，块和线程标签的排序方式是最高维度优先。这种标记方式的顺序与 C 语句中设置配置参数的顺序相反，

后者是最低维度优先。这种用于标记块的逆序在我们说明线程坐标映射到数据索引以访问多维数据时效果更好。

每个 `threadIdx` 也由三个字段组成：x 坐标 `threadId.x`、y 坐标 `threadIdx.y` 和 z 坐标 `threadIdx.z`。图 3.1 说明了块内线程的组织方式。在此示例中，每个块被组织成 4 * 2 * 2 的线程数组。由于网格中的所有块具有相同的维度，我们仅展示其中一个。图 3.1 展开了块 (1,1) 以显示其 16 个线程。例如，线程 (1,0,2) 的 `threadIdx.z=1`、`threadIdx.y=0` 和 `threadIdx.x=2`。请注意，在此示例中，我们有 4 个块，每个块 16 个线程，总共有 64 个线程在网格中。我们使用这些小数字来保持插图的简单性。典型的 CUDA 网格包含成千上万甚至数百万个线程。


## 3.2 将线程映射到多维数据

选择一维、二维或三维线程组织通常基于数据的性质。例如，图像是一个二维像素数组。使用由二维块组成的二维网格来处理图像中的像素通常很方便。

![image](https://github.com/user-attachments/assets/4dd48257-ef11-4bb3-802d-592707c341e5)
> 图3.2 

图3.2展示了处理一个62×76像素图片P的这种排列方式（垂直方向或y方向有62个像素，水平方向或x方向有76个像素）。假设我们决定使用16×16的块，在x方向和y方向各有16个线程。我们将在y方向需要四个块，在x方向需要五个块，总共需要4×5=20个块，如图3.2所示。粗线标记块的边界。阴影区域描绘了覆盖像素的线程。每个线程被分配处理一个像素，其y和x坐标由其`blockIdx`、`blockDim`和`threadIdx`变量值确定：

```
垂直（行）坐标 = blockIdx.y * blockDim.y + threadIdx.y
水平（列）坐标 = blockIdx.x * blockDim.x + threadIdx.x
```

例如，块(1,0)的线程(0,0)处理的Pin元素可以如下标识：
$$ Pin_{blockIdx.y * blockDim.y + threadIdx.y, blockIdx.x * blockDim.x + threadIdx.x} = Pin_{1 * 16 + 0, 0 * 16 + 0} = Pin_{16, 0} $$

请注意，在图3.2中我们在y方向有两个额外的线程，在x方向有四个额外的线程。也就是说，我们将生成64×80个线程来处理62×76个像素。这类似于图2.9中1D核函数`vecAddKernel`处理1000个元素向量的情况，使用四个256线程块。回想图2.10中的if语句用于防止额外的24个线程生效。同样，我们应该预期图片处理核函数将包含if语句以测试线程的垂直和水平索引是否在像素的有效范围内。

我们假设主机代码使用整数变量n跟踪y方向上的像素数量，另一个整数变量m跟踪x方向上的像素数量。我们进一步假设输入图片数据已复制到设备全局内存中，可以通过指针变量`Pin_d`访问。输出图片已在设备内存中分配，可以通过指针变量`Pout_d`访问。以下主机代码可以用来调用一个二维核函数`colorToGrayscaleConversion`来处理图片，如下所示：

```cuda
dim3 dimGrid(ceil(m/16.0), ceil(n/16.0), 1); 
dim3 dimBlock(16, 16, 1);
colorToGrayscaleConversion<<<dimGrid, dimBlock>>>(Pin_d, Pout_d, m, n);
```

在这个例子中，为简化起见，我们假设块的维度固定为16×16。而网格的维度则取决于图片的维度。要处理一个1500×2000（300万像素）的图片，我们将生成11,750个块：y方向94个块，x方向125个块。在核函数内，引用`gridDim.x`、`gridDim.y`、`blockDim.x`和`blockDim.y`将分别得到125、94、16和16。

在展示核代码之前，我们首先需要了解C语句如何访问动态分配的多维数组的元素。理想情况下，我们希望将`Pin_d`作为二维数组访问，其中行j和列i的元素可以作为`Pin_d[j][i]`访问。然而，根据CUDA C开发的ANSI C标准要求，必须在编译时知道Pin中的列数才能将其作为二维数组访问。不幸的是，对于动态分配的数组，在编译时无法知道这个信息。实际上，使用动态分配的数组的部分原因是允许这些数组的大小和维度根据运行时的数据大小而变化。

因此，动态分配的二维数组的列数信息在编译时设计上是未知的。结果，程序员需要显式地将动态分配的二维数组线性化，或“展平”，为当前的CUDA C中的等效一维数组。

实际上，C中的所有多维数组都是线性化的。这是由于现代计算机中使用“平面”内存空间（参见“内存空间”侧边栏）。对于静态分配的数组，编译器允许程序员使用高维索引语法（例如`Pin_d[j][i]`）来访问其元素。在底层，编译器将它们线性化为等效的一维数组，并将多维索引语法转换为一维偏移。

对于动态分配的数组，当前的CUDA C编译器将这种转换工作留给程序员，因为编译时缺乏维度信息。

> ### 内存空间
> 内存空间是处理器在现代计算机中访问其内存的一种简化视图。内存空间通常与每个运行的应用程序相关联。要由应用程序处理的数据和为应用程序执行的指令存储在其内存空间中的位置。每个位置通常可以容纳一个字节并有一个地址。需要多个字节的变量——浮点数为4个字节，双精度浮点数为8个字节——存储在连续的字节位置。当从内存空间访问数据值时，处理器会给出起始地址（起始字节位置的地址）和所需的字节数。
> 大多数现代计算机至少有4G个字节大小的位置，其中每个G为1,073,741,824（2<sup>30</sup>）。所有位置都有一个从0到最大编号的地址标签。由于每个位置只有一个地址，我们说内存空间具有“平面”组织。结果，所有多维数组最终都被“展平”成等效的一维数组。虽然C程序员可以使用多维数组语法来访问多维数组的元素，但编译器将这些访问转换为指向数组起始元素的基指针以及由这些多维索引计算出的一维偏移。

![image](https://github.com/user-attachments/assets/c8fd7c97-3998-46dc-8a13-ae4791477683)
> 图3.3 C数组的行优先布局。结果是一个等效的一维数组，用索引表达式j*Width+i访问，其中j是行，i是列，一个数组中每行有Width个元素。

有至少两种方法可以线性化二维数组。其一是将同一行的所有元素放入连续位置。然后将行按顺序放入内存空间。这种排列称为行优先布局，如图3.3所示。为了提高可读性，我们用M<sub>j,i</sub>表示第j行第i列的元素M。M<sub>j,i</sub>等效于C表达式M[j][i]，但稍微更易读。图3.3显示了一个4×4矩阵M被线性化为16个元素的一维数组，首先是第0行的所有元素，然后是第1行的四个元素，依此类推。

因此，行j和列i的元素M的等效一维索引为j*4+i。j*4项跳过j行之前的所有元素。i项然后在j行部分中选择正确的元素。例如，M<sub>2,1</sub>的一维索引为2*4+1=9。这在图3.3中有所说明，其中M<sub>9</sub>是M<sub>2,1</sub>的一维等效元素。这就是C编译器线性化二维数组的方式。

另一种线性化二维数组的方法是将同一列的所有元素放入连续位置。然后将列按顺序放入内存空间。这种排列称为列优先布局，由FORTRAN编译器使用。注意二维数组的列优先布局等效于其转置形式的行优先布局。我们不会花更多时间在这个上面，除了提到那些主要先前编程经验是FORTRAN的读者应该意识到CUDA C使用行优先布局而非列优先布局。此外，许多为FORTRAN程序设计的C库使用列优先布局以匹配FORTRAN编译器布局。因此，这些库的手册页通常告诉用户，如果从C程序调用这些库，应转置输入数组。

```cuda
__global__ void colortoGrayscaleConvertion(unsigned char * Pout, unsigned char * Pin, int width, int height) {
    // 计算当前线程对应的列索引
    int col = blockIdx.x * blockDim.x + threadIdx.x;

    // 计算当前线程对应的行索引
    int row = blockIdx.y * blockDim.y + threadIdx.y;

    // 检查线程是否在图像范围内
    if (col < width && row < height) {
        // 计算灰度图像中对应像素的偏移量
        int grayOffset = row * width + col;
        // 计算RGB图像中对应像素的偏移量
        int rgbOffset = grayOffset * CHANNELS;

        // 获取RGB值
        unsigned char r = Pin[rgbOffset];
        unsigned char g = Pin[rgbOffset + 1];
        unsigned char b = Pin[rgbOffset + 2];

        // 将RGB转换为灰度并存储到输出图像
        Pout[grayOffset] = 0.21f * r + 0.71f * g + 0.07f * b;
    }
}
```

我们现在准备研究 `colorToGrayscaleConversion` 的源代码，如图 3.4 所示。内核代码使用以下公式将每个彩色像素转换为其灰度像素：

$$ L = 0.12r + 0.72g + 0.07b $$

在水平方向上共有 `blockDim.x * gridDim.x` 个线程。与 `vecAddKernel` 示例类似，以下表达式生成从 0 到 `blockDim.x * gridDim.x - 1` 的每个整数值（第 06 行）：

```cuda
col = blockIdx.x * blockDim.x + threadIdx.x
```

我们知道 `gridDim.x * blockDim.x` 大于或等于宽度（从主机代码传入的 `m` 值）。我们至少有与水平方向像素数量相同的线程。我们还知道垂直方向的线程数量至少与像素数量相同。因此，只要我们测试并确保只有具有行值和列值在范围内的线程，即 `(col < width) && (row < height)`，我们就可以覆盖图片中的每个像素（第 07 行）。

由于每行有 `width` 个像素，我们可以生成像素在 `row` 行和 `col` 列处的 1D 索引，方法是 `row * width + col`（第 10 行）。这个 1D 索引是 `Pout` 的像素索引，因为输出灰度图像中的每个像素都是 1 字节（无符号字符）。在我们 62*76 的图像示例中，线程 (0,0) 处理的 `Pout` 像素的线性化 1D 索引由以下公式计算：

$$ Pout_{blockIdx.y * blockDim.y + threadIdx.y, blockIdx.x * blockDim.x + threadIdx.x} = Pout_{1 * 16 + 0, 0 * 16 + 0} = Pout_{16, 0} = Pout_{[16 * 76 + 0]} = Pout_{[1216]} $$

至于 `Pin`，我们需要将灰度像素索引乘以 3（第 13 行），因为每个彩色像素存储为三个元素（r、g、b），每个元素都是 1 字节。生成的 `rgbOffset` 给出了 `Pin` 数组中彩色像素的起始位置。我们从 `Pin` 数组的三个连续字节位置读取 r、g 和 b 值（第 14-16 行），计算灰度像素值，并使用 `grayOffset` 将该值写入 `Pout` 数组（第 19 行）。在我们 62*76 的图像示例中，线程 (0,0) 处理的 `Pin` 像素第一个分量的线性化 1D 索引可以通过以下公式计算：

$$ Pin_{blockIdx.y * blockDim.y + threadIdx.y, blockIdx.x + blockDim.x + threadIdx.x} = Pin_{1 * 16 + 0, 0 * 16 + 0} = Pin_{16, 0} = Pin_{[16 * 76 * 3 + 0]} = Pin_{[3648]} $$

![image](https://github.com/user-attachments/assets/5c025a39-b925-4182-afa4-4e600401e053)
> 图 3.5 用 16*16 的块覆盖 76*62 的图片。

访问的数据是从字节偏移量 3648 开始的 3 个字节。图 3.5 说明了 `colorToGrayscaleConversion` 在处理我们 62*76 的示例时的执行情况。假设 16*16 的块，调用 `colorToGrayscaleConversion` 内核生成 64*80 线程。网格将有 4*5=20 个块：垂直方向四个，水平方向五个。块的执行行为将分为四种不同的情况，如图 3.5 中的四个阴影区域所示。

第一个区域，图 3.5 中标记为 1，包括属于覆盖图片大多数像素的 12 个块的线程。这些线程的 `col` 和 `row` 值都在范围内；所有这些线程通过 if 语句测试并处理图片深色阴影区域的像素。即每个块中所有 16*16=256 个线程都将处理像素。

第二个区域，图 3.5 中标记为 2，包含属于中等阴影区域覆盖图片右上像素的三个块的线程。虽然这些线程的行值始终在范围内，但其中一些线程的列值超过了 76 的 m 值。这是因为水平方向上的线程数始终是程序员选择的 `blockDim.x` 值的倍数（在本例中为 16）。覆盖 76 个像素所需的最小 16 的倍数是 80。因此，每行的 12 个线程会发现其列值在范围内并处理像素。其余四个线程将发现其列值超出范围，因此不会通过 if 语句条件。这些线程不会处理任何像素。总体而言，这些块中的 12*16=192 个线程中的 256 个线程将处理像素。

第三个区域，图 3.5 中标记为 3，占据覆盖图片中等阴影区域的左下方四个块。虽然这些线程的列值始终在范围内，但其中一些线程的行值超过了 62 的 n 值。这是因为垂直方向上的线程数始终是程序员选择的 `blockDim.y` 值的倍数（在本例中为 16）。覆盖 62 所需的最小 16 的倍数是 64。因此，每列的 14 个线程会发现其行值在范围内并处理像素。其余两个线程将不会通过 if 语句条件，不会处理任何像素。总体而言，这些块中的 16*14=224 个线程将处理像素。

第四个区域，图 3.5 中标记为 4，包含覆盖图片右下方轻度阴影区域的线程。与区域 2 类似，每列顶部的 4 个线程会发现其列值超出范围。与区域 3 类似，这些块的整个底部两行的线程会发现其行值超出范围。总体而言，只有 14*12=168 个线程中的 256 个线程将处理像素。

我们可以通过在线性化数组时包括另一个维度，将我们的讨论从 2D 数组轻松扩展到 3D 数组。这是通过将数组的每个“平面”一个接一个地放入地址空间来完成的。假设程序员使用变量 `m` 和 `n` 跟踪 3D 数组中列和行的数量。程序员还需要确定在调用内核时 `blockDim.z` 和 `gridDim.z` 的值。在内核中，数组索引将涉及另一个全局索引：

```cuda
int plane = blockIdx.z*blockDim.z + threadIdx.z
```

对 3D 数组 `P` 的线性访问形式为 `P[plane * m * n + row * m + col]`。处理 3D `P` 数组的内核需要检查 `plane`、`row` 和 `col` 的所有三个全局索引是否在数组的有效范围内。在第8章，Stencil 模式中，我们将进一步研究 CUDA 内核中的 3D 数组的使用。
