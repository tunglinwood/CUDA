# 2_异构数据并行计算

* [2.1 数据并行性]()
* [2.2 CUDA C程序结构]()
* [2.3 向量加法内核]()
* [2.4 设备全局内存和数据传输]()
* [2.5 内核函数和线程]()
* [2.6 调用内核函数]()
* [2.7 编译]()
* [2.8 总结]()
* [练习]()

数据并行性是指对数据集不同部分的计算工作可以相互独立地完成，因此可以并行进行。许多应用程序表现出大量的数据并行性，使它们适合于可扩展的并行执行。因此，并行程序员必须熟悉数据并行性的概念以及用于编写利用数据并行性的代码的并行编程语言构造。在本章中，我们将使用CUDA C语言构造开发一个简单的数据并行程序。

## 2.1 数据并行性
当现代软件应用程序运行缓慢时，问题通常出在数据上——需要处理的数据太多。图像处理应用程序处理具有数百万到万亿像素的图像或视频。科学应用程序使用数十亿网格点建模流体动力学。分子动力学应用程序必须模拟成千上亿原子之间的相互作用。航空公司调度处理数千次航班、机组人员和机场登机口。这些像素、粒子、网格点、相互作用、航班等大多数通常可以独立处理。例如，在图像处理中，将彩色像素转换为灰度仅需要该像素的数据。模糊图像时，将每个像素的颜色与附近像素的颜色平均，只需该小区域内的像素数据。即使是看似全局的操作，例如找到图像中所有像素的平均亮度，也可以分解为许多可以独立执行的小计算。这种对不同数据片段的独立评估是数据并行性的基础。编写数据并行代码意味着围绕数据（重新）组织计算，以便我们可以并行执行结果的独立计算，从而更快地完成整体任务——通常要快得多。

![image](https://github.com/user-attachments/assets/d49864d9-1a50-4d0f-9d8a-e44e33c07d55)

让我们通过一个彩色转灰度转换的例子来说明数据并行性的概念。图2.1显示了一张由许多像素组成的彩色图像（左侧），每个像素包含一个从0（黑色）到1（全强度）变化的红色、绿色和蓝色分数值（r, g, b）。
要将彩色图像（图2.1的左侧）转换为灰度图像（右侧），我们需要通过应用以下加权和公式来计算每个像素的亮度值L：
$$ L = 0.21r + 0.72g + 0.07b $$

> RGB颜色图像表示
  在RGB表示中，图像中的每个像素被存储为一个(r, g, b)值的元组。图像行的格式为(r g b) (r g b) . . . (r g b)，如下面的概念图所示。每个元组指定了红色（R）、绿色（G）和蓝色（B）的混合比例。换句话说，对于每个像素，r、g和b值代表了在像素呈现时红色、绿色和蓝色光源的强度（0表示黑暗，1表示全强度）。
> ![image](https://github.com/user-attachments/assets/47c6ad49-4007-45a9-9083-1fe5a27f68e1)
> 这三种颜色的实际混合比例在行业指定的颜色空间中有所不同。在这里，AdobeRGB颜色空间中三种颜色的有效组合被显示为三角形的内部区域。
  每种混合的垂直坐标（y值）和水平坐标（x值）显示了像素强度的G和R分量的比例。剩余部分（1-y-x）的像素强度分配给B。为了呈现图像，每个像素的r、g、b值用于计算像素的总强度（亮度）以及混合系数（x、y、1-y-x）。

如果我们将输入视为一个由RGB值组成的数组I，而输出视为相应的亮度值数组O，我们将得到如图2.2所示的简单计算结构。例如，O[0]是通过根据上述公式计算I[0]中的RGB值的加权和生成的；O[1]是通过计算I[1]中的RGB值的加权和生成的；O[2]是通过计算I[2]中的RGB值的加权和生成的；依此类推。这些每像素的计算彼此之间没有依赖关系。所有这些计算都可以独立进行。显然，颜色到灰度的转换表现出丰富的数据并行性。当然，完整应用中的数据并行性可能更为复杂，本书的大部分内容都致力于教授找到和利用数据并行性所需的并行思维。

> 
